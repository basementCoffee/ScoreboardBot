const pkg = require('../package.json');
const Youtube = require('youtube-sr').default;
const { Readable } = require('stream'); // eslint-disable-line no-unused-vars
const ytdl = require('discord-ytdl-core');
const fetch = require('node-fetch');
const SpotifyWebApi = require('spotify-web-api-node');
const spotifyApi = new SpotifyWebApi({
  clientId: '544109f2efdc4f6f9e429ca74bdacc9f',
  clientSecret: '8c05fc01247a4683ad09c3583e796ab4'
});

/**
 * @typedef {Object} trackInfo
 * @property {string} title The track title
 * @property {string[]} artists The track artists
 * @property {string} url The track url
 * @property {string} id The track id
 * @property {string} uri The track uri
 * @property {number?} duration The track duration
 * @property {string} thumbnail The track thumbnail
 * @property {string} preview_url A link to a 30 second preview (MP3 format) of the track. Can be null
 */

/**
 * Downloads the track from the given url. Returns a readable stream
 * @param {string} url The track url
 * @param {Object} options The download options
 * @returns {Promise<Readable>} The readable stream
 */
const spdl = async (url, options = {}) => {
  return new Promise(async (resolve, reject) => { // eslint-disable-line no-async-promise-executor
    try {
      if (!SPDLCore.validateURL(url)) return reject(new Error('Invalid URL'));
      const data = await fetch('https://accounts.spotify.com/api/token?grant_type=client_credentials', {
        method: 'POST',
        headers: {
          authorization: `Basic ${Buffer.from(`${spotifyApi.getCredentials().clientId}:${spotifyApi.getCredentials().clientSecret}`).toString('base64')}`,
          'Content-Type': 'application/x-www-form-urlencoded'
        }
      });
      const json = await data.json();
      spotifyApi.setAccessToken(json.access_token);
      const infos = await spotifyApi.getTrack(SPDLCore.getURLTrackID(url));
      if (!infos) return reject(new Error('Track not found'));
      let video = await Youtube.searchOne(`${infos.body.name} ${infos.body.artists[0].name}`);
      if (!video) video = await Youtube.searchOne(`${infos.body.name}`);
      if (!video || video.views === 0) return reject(new Error('Track not found'));
      return resolve(ytdl(video.url, options));
    } catch (err) {
      return reject(err);
    }
  });
};

class SPDLCore {
  constructor () {
    throw new Error(`The ${this.constructor.name} class may not be instantiated!`);
  }

  /**
   * Gives the information of a track
   * @param {string} url The track url
   * @returns {Promise<trackInfo>} The track info
   */
  static async getInfo (url) {
    return new Promise(async (resolve, reject) => { // eslint-disable-line no-async-promise-executor
      if (!SPDLCore.validateURL(url)) return reject(new Error('Invalid URL'));
      const data = await fetch('https://accounts.spotify.com/api/token?grant_type=client_credentials', {
        method: 'POST',
        headers: {
          authorization: `Basic ${Buffer.from(`${spotifyApi.getCredentials().clientId}:${spotifyApi.getCredentials().clientSecret}`).toString('base64')}`,
          'Content-Type': 'application/x-www-form-urlencoded'
        }
      }).catch(err => reject(err));
      const json = await data.json().catch(err => reject(err));
      spotifyApi.setAccessToken(json.access_token);
      const infos = await spotifyApi.getTrack(SPDLCore.getURLTrackID(url)).catch(err => reject(err));
      if (!infos) return reject(new Error('Track not found'));
      let video = await Youtube.searchOne(`${infos.body.name} ${infos.body.artists[0].name}`).catch(err => reject(err));
      if (!video) video = await Youtube.searchOne(`${infos.body.name}`).catch(err => reject(err));
      if (!video || video.views === 0) return reject(new Error('Track not found'));
      return resolve({
        title: infos.body.name,
        artists: infos.body.artists.map(a => a.name),
        url: infos.body.external_urls.spotify,
        id: infos.body.id,
        uri: infos.body.uri,
        duration: video.duration,
        thumbnail: infos.body.album.images[0].url,
        preview_url: infos.body.preview_url
      });
    });
  }

  /**
   * Returns true if url is a spotify track link
   * @param {string} url The track url
   * @returns {boolean} Is a spotify link
   */
  static validateURL (url) {
    return /^https?:\/\/(?:open|play)\.spotify\.com\/track\/[\w\d]+$/i.test(SPDLCore.parse(url));
  }

  /**
   * Sets the module credentials to yours
   * @param {string} clientId You app's clientId
   * @param {string} clientSecret Your app's clientSecret
   */
  static setCredentials (clientId, clientSecret) {
    spotifyApi.setCredentials({
      clientSecret,
      clientId
    });
  }

  /**
   * Sets the module credentials to yours
   * @param {string} clientId You app's clientId
   */
  static setClientId (clientId) {
    spotifyApi.setClientId(clientId);
  }

  /**
   * Sets the module credentials to yours
   * @param {string} clientSecret You app's clientSecret
   */
  static setClientSecret (clientSecret) {
    spotifyApi.setClientSecret(clientSecret);
  }

  /**
   * Gets the track ID from the given url
   * @param {string} url The track url
   * @returns {string} The track ID
   * @ignore
   */
  static getURLTrackID (url) {
    if (!SPDLCore.validateURL(url)) return new Error('Invalid URL');
    return SPDLCore.parse(url).split('track/')[1];
  }

  /**
   * Returns a beautified spotify url
   * @param {string} url The url to beautify
   * @returns {string} The beautified url
   * @ignore
   */
  static parse (url) {
    return url.split('?')[0];
  }

  /**
   * Checks for updates
   * @ignore
   */
  static async updater () {
    if (!process.env.SPDL_NO_UPDATE) {
      try {
        const fetched = await fetch('https://api.github.com/repos/SkyDonald/spdl-core/releases/latest', {
          headers: {
            'User-Agent': `spdl-core v${pkg.version}`
          }
        });
        const data = await fetched.json();

        if (data.tag_name !== `v${pkg.version}`) {
          console.warn('\x1b[33mWARNING:\x1B[0m spdl-core is out of date! Update with "npm install spdl-core@latest"');
        }
      } catch (err) {
        console.warn('Error checking for updates: ', err.message);
        console.warn('You can disable this check by setting the `SPDL_NO_UPDATE` env variable to false');
      }
    }
  }

  /**
   * Search for tracks
   * @param {string} query The track title
   * @returns {Promise<trackInfo[]>} The searched tracks
   */
  static async search (query) {
    return new Promise(async (resolve, reject) => { // eslint-disable-line no-async-promise-executor
      const data = await fetch('https://accounts.spotify.com/api/token?grant_type=client_credentials', {
        method: 'POST',
        headers: {
          authorization: `Basic ${Buffer.from(`${spotifyApi.getCredentials().clientId}:${spotifyApi.getCredentials().clientSecret}`).toString('base64')}`,
          'Content-Type': 'application/x-www-form-urlencoded'
        }
      });
      const json = await data.json();
      spotifyApi.setAccessToken(json.access_token);
      const infos = await spotifyApi.searchTracks(query);
      if (!infos) return reject(new Error('Track not found'));
      const searched = [];
      infos.body.tracks.items.forEach(info => {
        searched.push({
          title: info.name,
          artists: info.artists.map(a => a.name),
          url: info.external_urls.spotify,
          id: info.id,
          uri: info.uri,
          thumbnail: info.album.images[0].url,
          preview_url: info.preview_url
        });
      });
      return resolve(searched);
    });
  }

  /**
   * Downloads the track from the given query. Returns a readable stream
   * @param {string} query The track title
   * @param {Object} options The download options
   * @returns {Promise<Readable>} The readable stream
   */
  static async searchAndDownload (query, options) {
    return new Promise(async (resolve, reject) => { // eslint-disable-line no-async-promise-executor
      const data = await fetch('https://accounts.spotify.com/api/token?grant_type=client_credentials', {
        method: 'POST',
        headers: {
          authorization: `Basic ${Buffer.from(`${spotifyApi.getCredentials().clientId}:${spotifyApi.getCredentials().clientSecret}`).toString('base64')}`,
          'Content-Type': 'application/x-www-form-urlencoded'
        }
      });
      const json = await data.json();
      spotifyApi.setAccessToken(json.access_token);
      const infos = await spotifyApi.searchTracks(query);
      if (!infos) return reject(new Error('Track not found'));
      let video = await Youtube.searchOne(`${infos.body.name} ${infos.body.artists[0].name}`);
      if (!video) video = await Youtube.searchOne(`${infos.body.name}`);
      if (!video || video.views === 0) return reject(new Error('Track not found'));
      return resolve(ytdl(video.url, options));
    });
  }
}

spdl.validateURL = SPDLCore.validateURL;
spdl.getInfo = SPDLCore.getInfo;
spdl.setCredentials = SPDLCore.setCredentials;
spdl.setClientId = SPDLCore.setClientId;
spdl.setClientSecret = SPDLCore.setClientSecret;

SPDLCore.updater();

module.exports = spdl;
module.exports.default = spdl;
